JAVA:
ITERATIVE SELECTION SORT

package akash;  //program is insertion sort

public class selection_sort {  

	public static void main(String[] args) {
		
		int a[]={4,9,1,3,2,0,11,456,98,5},temp,min,pos=0;
		
		 
		
		
			for(int j=0;j<(a.length)-1;j++)
			{
				min=a[j];
				
				   for(int i=j+1;i<a.length;i++)
				   {
				       if(a[i]<min)
				       {
					       min=a[i];
				         pos=i;
				       }
				   }
				   if(min!=a[j]) // this condition ensures that if there is no element smaller than the current min then swap does not take place.
				   {
				   temp=a[j];
				   a[j]=min;
				   a[pos]=temp;
				   }
				   
				   
				   
			}
				 
				   
				
				
		for(int k=0;k<a.length;k++)
			System.out.println(a[k]);
		
	}

}




RECURSIVE SELECTION SORT:

package akash;

public class recursiv_insertionsort {

	public static void main(String[] args) {
		int[] a={4,9,1,3,2,0,11,456,98,5,0};
				int n=0;
		  
				doSelection_sort( a, n);
				for(int k=0;k<a.length;k++)
					System.out.println(a[k]);
		
		

	}

	
	
	public static int doSelection_sort(int[] a,int n){
		int min,temp,pos=0;
		if(n==a.length-1)
			return 0;
		
		else{
			
			
			min=a[n];
			
			   for(int i=n+1;i<a.length;i++)
			   {
			       if(a[i]<min)
			       {
				       min=a[i];
			         pos=i;
			       }
			   }
			   if(min!=a[n]) // this condition ensures that if there is no element smaller than the current min then swap does not take place.
			   {
			   temp=a[n];
			   a[n]=min;
			   a[pos]=temp;
			   }
			 
			   return doSelection_sort(a,n+1);
			   
		    }
		
		
			
			
			
		}
		
		
		
	
}

SWAP TWO VARIABLES WITHOUT USING THIRD VARIABLE:

public class test {

	public static void main(String[] args) {
		
		int a=1371,b=1233;
	  a=a-b;//2
	  b=b+a;//9
		a=b-a;
		
		System.out.println("a="+ a + "b=" +b);
		

	}

}



DIVISION AND MODULUS:
int a=6;
c=a/10;
d=a%10;
print(c,d)

OUTPUT:
c=0
d=6




MERGING TWO SORTED ARRAYS:
public class test {

	public static void main(String[] args) {
		int a[]={2,5,6,7,8},b[]={1,3,9,11,56};
		int n=a.length+b.length;
		int[] arr=new int[n];
		
		
		int i=0,j=0,k=0;


		while(i<a.length && j<b.length)
		{
			
			
			if(a[i]<b[j])
			{
				arr[k]=a[i];
			  i++;
			}
			  
			  else
			  {
				  arr[k]=b[j];
			     j++;
			  }
			k++;
			
		}
		
		while(i<a.length){ //for the remaining elements in the array which were not filled in the new array
			
			arr[k]=a[i];
			i++;
			k++;
		}
         while(j<b.length){
			
			arr[k]=b[j];
			j++;
			k++;
         }
		
         for(int x=0;x<arr.length;x++)
  		   System.out.println(arr[x]);
  		   
		
	}
	
	
	
}
	
			
			
			
		
			
       
MERGE SORT:
package akash;

public class Merge_Sort {

	public static void main(String[] args) {
		int[] a={4,9,1,3,2,0,11,456,98,5,0,1,8976,-1,-4};
		Merge_Sort obj=new Merge_Sort();
	   obj.mergesort(a,0,a.length-1);
		
		for(int i=0;i<a.length;i++)
			System.out.println(a[i]);

	}
	


	public  void mergesort(int[]a,int low,int high){
		
		if(low<high)
			
			
		{
			int mid=(low+high)/2;
		    mergesort(a,low,mid);
		    mergesort(a,mid+1,high);
		   merge(a,low,mid,high);
		}
		
		
		
	}
	public static  void merge(int[]a,int low,int mid,int high){
		
		
		int n1=mid-low+1;
	        int n2=high-mid;
	        int[] L=new int[n1]  ;
	    	int[] R=new int[n2];

	    for(int i=0;i<n1;i++)
	    	L[i]=a[low+i];
	    
	    for(int j=0;j<n2;j++)
	    	R[j]=a[mid+1+j];
	    
	    int i=0,j=0,k=low;
	  
	  while(i<L.length && j<R.length)
	  {
		  
		  if(L[i]<R[j])
		  {
			  a[k]=L[i];
			  i++;
			  
		  }
		  
		  else{
			  
			  a[k]=R[j];
			  j++;
			  
			}
		  k++;
	    
	    
	  }
	  
	  while(i<L.length){
		  
		  a[k]=L[i];
		  i++;
		  k++;
	    
	    }
      while(j<R.length){
		  
		  a[k]=R[j];
		  j++;
		  k++;
	    
	         }		
		
}
}



BINARY SEARCH:
public class test { 

	public static void main(String[] args) {
		int[] arr={1,3,4,6,8,9,11,123,456,3400};
		int tar=11;
		test obj=new test();
		int x=obj.fact(arr,0,arr.length-1,tar);
		if(x!=0)
		System.out.println("the pos is:"+ x);
		
				 
			 
	
	}
	
	public int fact(int []arr,int low,int high,int x)
	{ 
		int mid=(low+high)/2;
		
		if(arr[mid]==x)
			return mid;
		
		else if(arr[mid]>x)
			 return fact(arr,low,mid-1,x);
		
		else if(arr[mid]<x)
			return fact(arr,mid+1,high,x);
		
		else
			return 0;
		
	}
		
	}
	
	

GCD:

public class test { 
	
	public static void main(String[] args){
int a=6,b=4;
   test obj=new test();
int k=obj.gcd(a,b);

      System.out.println(k);

}

public int gcd(int a,int b)
{
	  if(a==0 || b==0)
	  {
		  if(a==0)
			  return b;
		  else 
			  return a;
	  }
		   
	
     else if(a>b)
	 return  gcd(a%b,b);
	
	else if(b>a) 
		return  gcd(a,b%a);
	
	else
		return a;
	
	
}
	
}


COUNTING SORT:

public class test { 
	
	public static void main(String[] args){
int []arr={1,5,7,9,1,3,1,0,0};
int[] count=new int[10];
int [] b=new int[arr.length];

  for(int i=0;i<arr.length;i++)
  {
	 count[arr[i]]=count[arr[i]]+1;
  
   }
  for(int i=1;i<10;i++)
  {
	 count[i]=count[i-1]+count[i];
  
   }
  
 for(int j=0;j<arr.length;j++)
 {
	 
	 b[count[arr[j]]-1]=arr[j];
	 count[arr[j]]--;
	 
	 
 }
  
  
  
		  
        // for(int i=0;i<10;i++) 
        	 //System.out.println(count[i]);
         
         for(int i=0;i<arr.length;i++) 
        	 System.out.println(b[i]);
	  
	  
	  
  }
  
  
  
}



REMOVE DUPLICATE ELEMENTS IN AN ARRAY:

package akash;
import java.util.Scanner;




public class test { 
	
	public static void main(String[] args){
int []arr={1,3,4,5,3,1};
int n=arr.length;

  

   for(int i=0;i<n-1;i++)
   {
	   
	    for(int j=i+1;j<n;j++)
	    {
	    	
	    	if(arr[i]==arr[j])
	    	{
	    		
	    		for(int k=j;k<n-1;k++)
	    			arr[k]=arr[k+1];
	    		   
	    		n--;
	    		break;
	    	}
	    	else
	    		continue;
	    	
	    }
	   
	   
	   
   }
   
            
         for(int i=0;i<n;i++) 
        	 System.out.println(arr[i]);
	  
	  
	  
  }
  
  
  
}


REMOVE DUPLICATE ELEMENTS USING ANOTHER ARRAY:


package akash;
import java.util.Scanner;




public class test { 
	
	public static void main(String[] args){
int []arr={1,3,4,5,3,1};
int pos=0;int j;
int []b=new int[10];

    for(int i=0;i<arr.length;i++)
    {
    	  for( j=0;j<pos;j++)
    	  {
    		  
    		  if(arr[i]==b[j])
    			  break;
    		  
    	  }
    		  if(pos==j)
    		  {
    			  b[j]=arr[i];
    			  pos++;
    			  
    		  }
    		  
    		  
    }





            
         for(int i=0;i<b.length;i++) 
        	 System.out.print(b[i]);
	  
	  
	  
  }
  
  
  
}


TO COUNT THE ELEMENTS IN AN ARRAY WITH A GIVEN DIFFERENCE:
public class test { 
	
	public static void main(String[] args){
int []arr={1,2,3,4,5};int k=3;

test obj=new test();
for(int i=0;i<arr.length-1;i++){
int res=obj.binary(arr,i+1,arr.length-1,arr[i]+k);


if(res!=0)
	System.out.println("Then pairs are" + arr[i] + "and" + arr[res]);
 }
	
	}	
	
	
	public int binary(int []arr,int low,int high,int x)
	{ 
		
		if(low<=high)
		{
			int mid=(low+high)/2;
		if(arr[mid]==x)
		
			return mid;
			
		else if(arr[mid]>x)
			return binary(arr,low,mid-1,x);
		
		else if(arr[mid]<x)
			return binary(arr,mid+1,high,x);
			
		else 
			return 0;
		}
		
		else
			return 0;
	}
		
	}
	
OUTPUT:
Then pairs are:1 and 4
Then pairs are:2 and 5

	

  
TO FIND A STRING LENGTH USING RECURSION:

public static void main(String[] args) {
		String g="akash is great";
		problem14 obj=new problem14();
		int count=0;
		int k= obj.length(g,count);
		System.out.println(k);


	}
	public int length(String g,int count) {

		if(g.equals("")||g==null)
			return count;
		else
		{    
			count++;
			return length(g.substring(1),count);
		}

	}
}
OUTPUT:
14

PROGRAM TO COUNT TNE NUMBER OF PAIRS WHOSE SUM= THE GIVEN SUM


public class test{
public static void main(String[] args) {
	
	int[] x={0,1,3,9,11,12};
	
	
	int i=0;
	int j=x.length-1;
	int count=0;
	
	while(i!=j)
	{
		if(x[i]+x[j]==12){
			count++;
		    i++;
		}
		
		else if(x[i]+x[j]>12)
			j--;
		else
			i++;
		
	}
	
	System.out.println(count);
	
	
}
}

OUTPUT=3


PROGRAM TO COUNT THE NUMBER OF INVERSIONS IN A GIVEN ARRAY:

package akash;

public class Merge_Sort {

	public static void main(String[] args) {
		int[] a={2,4,1,3,5,0};
		Merge_Sort obj=new Merge_Sort();
	  int count= obj.mergesort(a,0,a.length-1);
		
		
			System.out.println(count);

	}
	


	public  int mergesort(int[]a,int low,int high){
		int inv_count=0;
		if(low<high)
			
			
		{
			int mid=(low+high)/2;
		   inv_count= mergesort(a,low,mid);
		   inv_count+=mergesort(a,mid+1,high);
		   inv_count+=merge(a,low,mid,high);
		}
		return inv_count;
		
		
	}
	public static  int merge(int[]a,int low,int mid,int high){
		
		int inv_count=0;
		int n1=(mid-low)+1;
	    int n2=high-mid;
	    int[] L=new int[n1]  ;
	    	int[] R=new int[n2];
	  
	    for(int i=0;i<n1;i++)
	    	L[i]=a[low+i];
	    
	    for(int j=0;j<n2;j++)
	    	R[j]=a[mid+1+j];
	    
	  int i=0,j=0,k=low;
	  
	  while(i<L.length && j<R.length)
	  {
		  
		  if(L[i]<R[j])
		  {
			  a[k]=L[i];
			  i++;
			
			  
		  }
		  
		  else{
			  
			  a[k]=R[j];
			  j++;
			  inv_count=inv_count+L.length-i;
			  
			}
		  k++;
	    
	    
	  }
	  
	  while(i<L.length){
		  
		  a[k]=L[i];
		  i++;
		  k++;
	    
	    }
      while(j<R.length){
		  
		  a[k]=R[j];
		  j++;
		  k++;
	    
	         }
	    
	  
		
		return inv_count;
		
}
}

output=8


RADIX SORT- PROGRAM TO SORT NUMBER DIGIT BY DIGIT USING COUNTING SORT AS A SUBROUTINE:


package akash;
import java.util.Scanner;
import java.lang.Math;

public class test{
public static void main(String[] args) {
	
	int[] x={141,22,45,63,33,241,2};
	//int b[]=new int[x.length];
	radix_sort(x);
	for(int j=0;j<x.length;j++)
		System.out.println(x[j]);
	
	
	
}
public static void radix_sort(int[]x){
	
	for(int i=1;(141/i)>0;i=i*10)
	{
                 int m=countMaxDigit(x,i);
		counting_sort(x,i,m);
	}
	
	
	
}	
	
	
 public static void counting_sort(int[]x,int b,int m)
 {
	 int count[]=new int[m+1];
	 int []y=new int[x.length];
	 
	 
	 
		for(int j=0;j<x.length;j++)
		  count[(x[j]/b)%10]++;
			
		
	 
	 
	 for(int i=1;i<count.length;i++)
		  count[i]=count[i]+count[i-1];
		  
	  for(int j=y.length-1;j>=0;j--)
	  {
		  
		  y[count[(x[j]/b)%10]-1]=x[j];
		  count[(x[j]/b)%10]--;
           
		  
	  } 
	  
	  for(int j=0;j<y.length;j++)
		 x[j]=y[j];
	
	}
public static int countMaxDigit(int x[],int i)
	{
		
		int max=0;
		
		for(int j=0;j<x.length;j++)
		{
			if((x[j]/i)%10>max)
               max=(x[j]/i)%10;
			
			
		}
		return max;
		
		
	}



}


step 1:start sorting by LSB:{141,22,45,63,33,241,2}
141,241,22,2,63,33,45
step 2:10's digit
2,22,33,45,141,241,63
step 3:MSB
2,22,33,45,63,141,241 /output




PROGRAM TO COUNT THE NUMBER OF DISTINCT ELEMENTS IN A WINDOW SIZE OF k:
ex. arr[]={1,2,1,3,4,2,3}
k=4;
count=3,4,4,3

USE SORTING AND COUNT THE DISTINCT ELEMENTS: 
arr[]={1,1,2,2,3,3,4}

package akash;
import java.util.Scanner;
import java.lang.Math;

public class test{
public static void main(String[] args) {
	
	int[] x={1,1,2,2,3,3,4};
	
	int i=0;int k=4;
	while((x.length-i)>=4)
{
		  count(x,i,i+3,k);
		   i++;
	}
	
	
	
	
}

public static void count(int[]x,int i,int j,int k)
{        int m=i+1;int count=0;
	  for(int l=i;l<j;l++)
	  {
		  
		  
		  if(x[l]==x[m])
	          count++;       //counting the elements which are repeated in the window
		  
		  
		       
		  m++;
		  
	  } 
		  
System.out.println(k-count);//subtracting the count of repeated elements from the the window gives us the
                             count of distinct elements	  
		  
	
}
}

WITOUHT USING SORTING:

package akash;

import java.io.*;
import java.util.Scanner;

public class tester{
    
	public static void main(String args[]) {
		
		int x[]={1,2,1,2,3,4,3};
		int win=3;
		int count=0;
		
		for(int i=0;i<=x.length-win;i++)
		{    count=0;
             for(int j=i;j<i+2;j++)
             {
                   int k=j+1;
                   while(k<i+3)
                   {
                	   if(x[j]==x[k])
                		   count++;
                	   
                	   k++;
                   }
             }
             if(count==0)
             System.out.println("the no of distinct element in window :"+i+" is "+(win-(count)));
             else
            	 System.out.println("the no of distinct element in window :"+i+"is "+(win-(count+1)));		
		}
		
	}
}
OUTPUT:
the no of distinct element in window :0is 1
the no of distinct element in window :1is 1
the no of distinct element in window :2 is 3
the no of distinct element in window :3 is 3
the no of distinct element in window :4is 1


PASCALS TRIANGLE :
USING BINOMIAL COEFF:

public class test{
public static void main(String[] args) {

//int n=4;
   
	for(int i=0;i<4;i++)
	{
        	for(int j=0;j<=i;j++)
			System.out.print((factorial(i))/(factorial(j)*factorial(i-j)));
		    
	
	
            System.out.println();
	} 
 }

public static int factorial(int n)
{
	if (n==0)
		return 1;
	
	else{
		
		return n*factorial(n-1);
		
		}
	
		
}

}
OUTPUT:
1
11
121
1331


USING MULTIDIMENSIONAL ARRAY:
public class test{
public static void main(String[] args) {

	int n[][]=new int[4][4];
	
	for(int row=0;row<4;row++)
	{
		
		for(int column=0;column<=row;column++)
		{
			if(row==column ||column==0)
				n[row][column]=1;
			else
				n[row][column]=n[row-1][column-1]+n[row-1][column];
			System.out.print(n[row][column]);
		}
		System.out.println();
	}	
	
}}

USING RECURSION:

public class test{
public static void main(String[] args) {

	int n=5;
	
	for(int i=0;i<n;i++)
	{
		
		for(int j=0;j<=i;j++)
			System.out.print(calculate(i,j)+" ");
		
		System.out.println();
		
	}
	
	
}
 public static int calculate(int row,int column) 
 {
	 if(column==0)
		 return 1;
	 else if(row==column)
		 return 1;
	 
	 else
      return calculate(row-1,column)+calculate(row-1,column-1);
		 
		 }

}

OUTPUT:	
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1	


FLOYD'S TRIANGLE:
public class aku {

	public static void main(String[] args) {


		int k=1;
		
		for(int i=0;i<5;i++)
		{
			
			for(int j=0;j<=i;j++)
			{
				System.out.print(k +" ");
				k++;
			}
			
			System.out.println();
			
			
		}
	}

}

OUTPUT:
1 
2 3 
4 5 6 
7 8 9 10 
11 12 13 14 15 


MATRIX MULTIPLICATION :

package akash;

public class aku {

	public static void main(String[] args) {
     
		int x[][]={{3,6},{5,8}};
		int y[][]={{2,3},{7,9}};     
		int c[][]=new int[2][2];
int sum=0;
    for(int i=0;i<x.length;i++)
    {
    	
    	for(int j=0;j<y.length;j++)
    	{ 
    		
    		for(int k=0;k<c.length;k++)
    		   sum+=x[i][k]*y[k][j];
    			
    		
    		c[i][j]=sum;
    		sum=0;
    		
        }
    	
    }
    for(int k=0;k<c.length;k++)
    {
    	for(int j=0;j<c.length;j++)
    		System.out.print(c[k][j]+" ");
    	
    	System.out.println();
    	
    }
	
	}

}	
OUTPUT:
48 63
66 87

MATRIX MULTIPLICATION USING RECURSION:
public class aku {

	public static void main(String[] args) {
     int i=0,j=0,k=0,sum=0;
		int x[][]={{3,6},{5,8}};
		int y[][]={{2,3},{7,9}};     
		int c[][]=new int[2][2];
		
		
		multiply(x,y,c,i,j,k,sum);
		 display(c);
		 
		
		
	}
	
	public static void multiply(int x[][],int y[][],int c[][],int i,int j,int k,int sum)
	{
	   if(i>=y.length)
	   {
		  return  ;
	   }
	   else if(i<x.length)
	   {
		   if(j<x.length)
		   {
			   if(k<y.length)
			   {
				     sum+=x[i][k]* y[k][j];
				    k++;
				    multiply( x, y, c, i, j, k,sum);
			   }
			   c[i][j]=sum;
			   k=0;
			   j++;
			  sum=0;
			  
			  multiply( x, y, c, i, j, k,sum);
			   
		  }
		   j=0;
		   i++;
		   
		  multiply( x, y, c, i, j, k,sum);
	   }   
		
	  
	 
    }
	
	 public static void display(int c[][])
	{
		
		 for(int l=0;l<c.length;l++)
		   {
			   for(int m=0;m<c.length;m++)
				   System.out.print(c[l][m]+ " ");
			   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
			   
			   
		   }
			  
		
		
	}
	   
	   
}
		

QUICK SORT:LAST ELEMENT AS PIVOT

package akash;
public class sample {

	public static void main(String[] args) {
     int x[]={6,1,5,3,0,2,7,5,1,4,0,3,4,23,100,9,320,12,43};
     quicksort(x,0,x.length-1);
     for(int i=0;i<x.length;i++)
    	 System.out.print(x[i]+" ");
	}

	public static void quicksort(int[] x, int low, int high) {
	  if(low<=high)
	  {
		  int k=partition(x, low, high);
		  quicksort(x,low,k-1);
		  quicksort(x,k+1,high);  
	  }
		
	}

	public static void swap(int x[],int first, int second) {
		int temp=x[first];
		x[first]=x[second];
		x[second]=temp;	
	}
	public static  int partition(int x[],int low,int high)
	{   
		int pivot=high;
		int j=pivot-1;
		int i=low;
		
		while(i<=j)
		{
			if(x[i]>=x[pivot])
			{
				swap(x,i,j);
				swap(x,j,pivot);
				pivot--;
				j--;
			}
			else 
				i++;	
		}
		
		
		
		return pivot;
	}

}

OUTPUT:
0 0 1 1 2 3 3 4 4 5 5 6 7 9 12 23 43 100 320 
 
QUICKSORT USING MEDIAN AS PIVOT:
package akash;
import java.util.Random;

public class test {

	public static void main(String[] args) {
		int x[]={6,1,4,9,0,3,5,2,7,8};
		 int low=0;int high=x.length-1;
		
		Random rand=new Random();
		
		 
		 
		quicksort(x,0,x.length-1);
		
		for(int i=0;i<x.length;i++)
			System.out.print(x[i]+" ");
		//System.out.print(pivot);
		//System.out.println();
		//System.out.print(p);
		

	}

	public static int partition(int x[],int low,int high,int pivot)
	{
	int temp;int last=high-1;
	
	   while(low<=last)
	   {
		while(x[low]<pivot)
			low++;
		
		while(x[last]>pivot)
			last--;
		
		if(low<last)
		{
			temp=x[low];
			x[low]=x[last];
			x[last]=temp;                                                                                                                                                          
		  
			low++;
			last--;
			
		}
			
			
	   }		
		
	   swap(x,low,high);
	   
	   return low;
	   
		}
		
	
	public static int median(int x[],int low,int high)
	{
		int center=(low+high)/2;
		
		if(x[low]>x[center])
			swap(x,low,center);
		
		if(x[low]>x[high])
			swap(x,low,high);
		 
		if(x[center]>x[high])
			swap(x,center,high);
		
		
		swap(x,center,high);
		
		return x[high];
		
		
	}
	
	public static  void swap(int x[],int first,int last)
	{
		
		int temp=x[first];
		x[first]=x[last];
		x[last]=temp;
		
		
		
	}
		
	
	public static void quicksort(int x[],int low,int high)
	{
		 if(low<high)
		 {
			 int med=median(x,low,high);
			 int part=partition( x,low,high,med);
			 quicksort(x,low,part-1);
			 quicksort(x,part+1,high);
			 
		 }
		
	}
	
}
OUTPUT:
0 1 2 3 4 5 6 7 8 9 


PROGRAM TO FIND A CONTIGUOUS SUBSET IN AN ARRAY OF +VE AND -VE INTEGERS WHICH GIVES
THE LARGEST SUM.RETURN THE SUM.
EQ:{2,-8,3,-2,4,-10}
OUTPUT=5 {3,-2,4}



public class tester{
    
	public static void main(String args[]) {
		
		int x[]={2,3,-8,-1,2,4,-2,3};
		
		 int sum=0,maxSum=0;
		 int i=0;
		 while(i<x.length)
		 {   
			 if(x[i]+sum>0){
			    sum+=x[i];
			    if(sum>maxSum)
					 maxSum=sum;
			 }
			 
			 else
			 {
				sum=0;
				     
			 }
			 i++;
		 }
		 System.out.println(maxSum);
		
	}
}

OUTPUT=7


PROGRAM TO PRINT THE FIRST SUBSET WITH THE SUM EQUAL TO THE GIVEN VALUE:

public class tester{
    
	public static void main(String args[]) {
		
		int[] x={2,3,1,0,6,3,1,3,5};
		int target=10;
		int j=1,k=0;
		int sum=0;
		ArrayList<Integer>arr=new ArrayList<>();
		int sumArr=0;
		int flag=0;
		
	    for(int i=0;i<x.length;i++)
	    {
	    	sumArr+=x[i];
	    }
		 while(k<x.length)
		 {   
			 if(sumArr<target)
			 {
				 flag++;
				 break;
			 }
			 
			 else if(sum==target)
				 break;
			 
			 else if(x[k]+sum<=target)
			 {   
				 sum+=x[k];
				 arr.add(x[k]);
				 k++;
			 }
			 else{
				 k=j;
				 j++;
				 sum=0;
				 arr.removeAll(arr);
			    }
			 
		 }
		 if(flag!=0)
			 System.out.println("target greater than array sum");
		 else
		   System.out.println(arr);
		
	}
}
OUTPUT:[3,1,0,6]
complexity=O(n)	      

PROGRAM TO CHECK IF A STRING IS A PALINDROME:

String original, reverse = "";
      Scanner in = new Scanner(System.in);
 
      System.out.println("Enter a string to check if it is a palindrome");
      original = in.nextLine();
 
      int length = original.length();
 
      for ( int i = length - 1; i >= 0; i-- )
         reverse = reverse + original.charAt(i);
 
      if (original.equals(reverse))
         System.out.println("Entered string is a palindrome.");
      else
         System.out.println("Entered string is not a palindrome.");
 
   }
}	



PROGRAM TO FIND IF TWO STRINGS ARE PERMUTATIONS OF EACH OTHER:

public static void main(String[] args) {
	
		
	String str=new String("ABC");
	String str1=new String("BAC");
	
	String s1=sort(str);
	String s2=sort(str1);
	
	if(s1.equals(s2))
		System.out.println("is permutation");
	else
		System.out.println("no permutation");
	
	
    
}

	public static String sort(String s)
	{
		char r[]=s.toCharArray();//converts string to character array
		java.util.Arrays.sort(r);//sorts the array
		return new String(r);//converts array intto string again and returns it
		
	}
	
}
		
OUTPUT:is permutation		
		
USING COUNTING TECHNIQUE OT FIND PERMUTATION:
public class test2 {

	public static void main(String[] args) {
		
	
	
	String s1=new String("BAR");
	String s2=new String("RAB");
	int k=0;
	int flag=0;
	int letter[]=new int[256];
	
	char[] str1=s1.toCharArray();
	
	for(int i=0;i<str1.length;i++)
		letter[(int)str1[i]]++;
	
	
	for(int j=0;j<s2.length();j++ ){
		 k = (int)s2.charAt(j);
		 letter[k]=letter[k]-1;
		 if(letter[k]<0)
			 flag++;
	}
	
	if(flag!=0)
		System.out.println("no permutation");
	else
		System.out.println( "permutation");
	
}		
			
}
		
OUTPUT:
permutation

MERGE FUNCTION:
	
public class test2 {

	public static void main(String[] args) {
		
	
	int  x[]={2,6,7,9};
	int y[]={1,3,5,11,13};
	int k=0;
	int i=0,j=0;
	int arr[]=new int[x.length+y.length];
	while(i<x.length && j<y.length)
	{
		if(x[i]<y[j])
		{
			arr[k]=x[i];
		    i++;
		}
		else
		{
			arr[k]=y[j];
			j++;
			
		}
		
		k++;
		
		
	}
	
      while(i<x.length)
      {
    	  arr[k]=x[i];
    	  i++;
    	  k++;
      }
      
      while(j<y.length)
      {
    	  arr[k]=y[j];
    	  j++;
    	  k++;
      }
    	  
    	  
      for(int m=0;m<arr.length;m++)
    	  System.out.print(arr[m]+" ");
      
      
   }
	
	
}
		

PROGRAM TO DETERMINE IF A STRING HAS ALL UNIQUE CHARACTERS:
Complexity=O(N):
package akash;

import java.util.Arrays;

public class test2 {

	public static void main(String[] args) {
		
	
	String str=new String("ABCDEGHF");
	Boolean char_set[]=new Boolean[256];
	Arrays.fill(char_set, Boolean.FALSE);
	int flag=0;
	if(str.length()>256)
		System.out.println("not unique.Exceeds length");
	
	for(int i=0;i<str.length();i++)
	{
		int val=str.charAt(i);
		if(char_set[val]){
			System.out.println("not unique");
			flag++;
		break;
		}
		
		char_set[val]=true;
		
	}
	   if(flag==0)
		System.out.println("unique");	
}
		
}

USING SORTING:O(NLOGN):
public class test2 {

	public static void main(String[] args) {
		
	
	String str=new String("ABCDEGHFD");
	int flag=0;
	char r[]=str.toCharArray();
	java.util.Arrays.sort(r);
	
	for(int i=0;i<r.length-1;i++)
	{
		
		if(r[i+1]==r[i]){
			System.out.println("not unique");
			flag++;
            break;	
		}
		
		
	}
	if(flag==0)
		System.out.println("unique");
		
}
}

PROGRAM TO COMPRESS A STRING:
eg:aabcccaa
outputshould be a2b1c3a2
where each character is follwed by its count:
O(N^2) solution:

public class test2 {

	public static void main(String[] args) {
		
	
	String str="aabcccccaaajjjkkk";
	
	
	String mystr="";
	char last=str.charAt(0);
	int count=1;
	for(int i=1;i<str.length();i++)
	{
		
		if(str.charAt(i)==last)
			count++;
		
		else
		{
			mystr+=last+""+count;
			last=str.charAt(i);
			count=1;
			
			
		}
		
	}
	     mystr+=last+""+count;
	  
		  System.out.println(mystr);
			
			}
		
	}
	
	
	
O(N) solution: find the length of the character array which will store the new elements:

public class test2 {

	public static void main(String[] args) {
		
	
	String str="aabccccccccccccaaa";
	
	
	String mystr="";
	int k=counting(str);
	System.out.println(k);
	char r[]=new char[k];
	int index=0;
	char last=str.charAt(0);
	int count=1;
	for(int i=1;i<str.length();i++)
	{
		
		if(str.charAt(i)==last)
			count++;
		
		else
		{
			//mystr+=last+""+count;
			index=setchar(r,last,index,count);
			last=str.charAt(i);
			count=1;
			
			
		}
		
	}
	    // mystr+=last+""+count;
	     setchar(r,last,index,count);
	      String rst=String.valueOf(r);
	      
		  System.out.println(rst);


			
		}
		
	
	public static int counting(String str)
	{
		int size=0;
		int count=1;
		char last=str.charAt(0);
		
		
		for(int i=1;i<str.length();i++)
		{
			
			if(str.charAt(i)==last)
				count++;
			
			else
			{
				last=str.charAt(i);
				size+=1+String.valueOf(count).length();
				count=1;
				//System.out.println(String.valueOf(count).length());
				
				
			}
			
		}
		
		size+=1+String.valueOf(count).length();
		return size;
		
		
		
	}
	public static int setchar(char r[],char last,int index,int count)
	{
		r[index]=last;
		index++;
		
		
		char ar[]=String.valueOf(count).toCharArray();
		
		for(char i=0;i<ar.length;i++)
		{
			r[index]=ar[i];
		     index++;
		}
		return index;
	}
	
	
		
	}
	
OUTPUT:
9
a2b1c12a3

String.valueOf(count).length:
this gives us the number of digits in count.
if count is 234
then this will give 3
if count is 12
this will give 2
	
			

PROGRAM TO SET THE ENTIRE ROW AND COLUMN TO ZERO IF AN ELEMENT IN A M*N MATRIX IS ZERO:
public class tester {

	public static void main(String[] args) {

int matrix[][]={{2,3,4},{7,0,9},{3,0,1},{0,1,2}};
//System.out.println(x.length);
boolean row[]=new boolean[matrix.length];
boolean column[]=new boolean[matrix[0].length];

     for(int i=0;i<matrix.length;i++)
     {
    	 for(int j=0;j<matrix[0].length;j++)
    	 {
    		 if(matrix[i][j]==0)
    		 {
    			 row[i]=true;
    			 column[j]=true;
    			 
    		 }
    		 
    		 
    	 }
     } 
    	 
    //nullify rows
    	 for(int j=0;j<row.length;j++){
    		 if(row[j])
    			 nullifyrow(matrix,j);
    	 }
    	 //nullify columns
    	 for(int k=0;k<column.length;k++){
    		 if(column[k])
    			 nullifycol(matrix,k);
    	 }
    	 	 

         for(int i=0;i<matrix.length;i++)
         {
        	 for(int j=0;j<matrix[0].length;j++) 
        		 System.out.print(matrix[i][j]+" ");
        		 
        	 System.out.println();
         }
     

	}
     public static void nullifyrow(int matrix[][],int m)
     {
    	 
    	 for(int i=0;i<matrix[0].length;i++)
    		 matrix[m][i]=0;
    	 
     }
     
     
     public static void nullifycol(int matrix[][],int m)
     {
    	 
    	 for(int i=0;i<matrix.length;i++)
    		 matrix[i][m]=0;
    	 
     }
     
}
OUTPUT:
2 0 4 
0 0 0 
0 0 0 
3 0 2 

FIND IF A STRING IS A SUBSTIRNG OF THE OTHER:
public class tester {

	public static void main(String[] args) {

		String str="waterbottle";
		String s2="bottl";
		
		//System.out.println(str.substring(1,10));
		if(isSubstring(str,s2))
			System.out.println("substring");
		else
			System.out.println("not substring");
		
		
		

	}
	
	public static boolean isSubstring(String s1,String s2)
	{    
		  if(s1.indexOf(s2)>0)
			  return true;
		  
		  
		return false;
		
		
		
	}
	
}
OUTPUT:
substring

PROGRAM TO CHECK IF ONE STRING IS A ROTATION OF THE OTHER:
public class tester {

	public static void main(String[] args) {

		String str="waterbottle";
		String s2="erbottlewat";
		String s1s1=str+str;
		if(isSubstring(s1s1,s2))
		System.out.println("substring");
		else
			System.out.println("not substring");
		
		
		

	}
	
	public static boolean isSubstring(String s1,String s2)
	{    
		  if(s1.indexOf(s2)>0)
			  return true;
		  
		  return false;
		
	}
}

OUTPUT:
substring
	
 SUBSET SUM USING RECURSION:
package akash;

public class tester {

	public static void main(String[] args) {
       
	
      int x[]={3,34,4,12,5,2};
        int sum=0;
        int i=0;
        int val=8;
        System.out.println(subset_sum(x,sum,i,val));
        
		
		
		
	}
	
	public static boolean  subset_sum(int x[],int sum,int i ,int val)
	{
		
		if(sum==val)
			return true;
		
		if(i==x.length)
			return false;
		
		boolean with= subset_sum(x,sum+x[i],i+1,val);
		boolean without= subset_sum(x,sum,i+1,val);
		
		return(with|| without);
			
		
	}
}
OUTPUT:
TRUE	
		
PROGRAM:THERE ARE TWO SORTED ARRAYS A AND B.MERGE B INTO A.
public class tester {

	public static void main(String[] args) {
       
		int x[]={1,5,7,9,0,0,0,0,0,0};
		int y[]={0,3,6,8,11,12};
		
int i=0,j=0;
int k=(x.length-y.length)+1;
//System.out.print(k);
      while(i<x.length && j<y.length && i<k-1)
      {
    	     if(y[j]<x[i])
    	     {
    	    	 for(int m=k-1;m>i;m--)
    	    	 {
    	    		  x[m]=x[m-1];
    	    		  
    	    		 
    	         }
    	    	 x[i]=y[j];
    	    	 k++;
    	    	i++;
    	    	j++;
    	     }
    	     else
    	    	 i++;
    	   
     }
      //System.out.print(i);
      while(i<x.length && j<y.length)
      {
    	  x[i]=y[j];
    	  j++;
    	  i++;
    	  
      }
      

      //System.out.print(k);
	for(int m=0;m<x.length;m++)
		System.out.print(x[m]+" ");

}
}
OUTPUT:
0 1 3 5 6 7 8 9 11 12 

PROGRAM TO SORT AN ARRAY OF STRINGS:
public class tester {

	public static void main(String[] args) {
       
		
	 String[] str={"akash","navdeep","ashitosh","kasha"};
		
		
	     for(int i=0;i<str.length;i++)
	     {
	    	 
	    	 char r[]=str[i].toCharArray();
	    	   java.util.Arrays.sort(r);
	    	   str[i]=new String(r);
	    	 
	    	 
	     }
	     for(int j=0;j<str.length;j++)
	    	 System.out.print(str[j]+" ");
		
}
}
OUTPUT:
aahks adeenpv ahhiosst aahks 

PROGRAM TO FIND A GIVEN NUMBER IN AN ARRAY OF N SORTED INTEGERS WHICH HAS BEEN ROTATED AN UNKNOWN
NUMBER OF TIMES:
EG:{15,16,19,20,25,1,3,4,5,7,10,14}
FIND 5:

public class tester {

	public static void main(String[] args) {
       
	int x[]={2,2,2,3,4,2};
	int low=0,high=x.length-1;
	int val=3;
	
	int k=search(x,low,high,val);
	System.out.println(k);
	
	
	
	
}
	public static int search(int x[],int low,int high,int val)
	{
		int mid=(low+high)/2;
		if(x[mid]==val)
			return mid;
		
		if(low>high)
			return -1;
		
		else if(x[low]<x[mid])
		{
			if(val>=x[low] && val<x[mid])
				return search(x,low,mid-1,val);
			else
				return search(x,mid+1,high,val);
			
			
		}
		else if(x[high]>x[mid])
		{
			if(val>x[mid] && val <=x[high])
				return search(x,mid+1,high,val);
			else
				return search(x,low,mid-1,val);
			
			
		}
		else if(x[low]==x[mid])
		{
			if(x[mid]!=x[high])
				return search(x,mid+1,high,val);
			else
			{
				int result= search(x,low,mid-1,val);
				if(result==-1)
					return search(x,mid+1,high,val);
				else
					return result;
			}
			
		}
		
		
		return -1;
	}
}
OUTPUT:
8




PROGRAM TO FIND A GIVEN STRING IN A ARRAY OF STRINGS WHICH IS SORTED:

public static void main(String[] args) {
       
	String s[]={"at","aku","bank","ball","cat","dashi","haramoz"};
	int low=0,high=s.length-1;
String val="cat";
   System.out.println( binarySearch(s,low,high,val));

	
}
	
	public static int binarySearch(String s[],int low,int high,String val)
	{
		
		int mid=(low+high)/2;
		  char r[]= s[mid].toCharArray();
		    char r1[]=val.toCharArray();
		 if(s[mid].equals(val))
			 return mid;
		 
		 if(high<low)
			 return -1;
		 
		 
		 else if((int)r1[0]>(int)r[0])
		       return binarySearch(s,mid+1,high,val);
		
		    else if((int)r1[0]<(int)r[0])
		    	 return binarySearch(s,low,mid-1,val);
		
		    else
		    	return -1;
	}
	
	
}
OUTPUT:
4	

PROGRAM TO FIND A GVIEN STRING IN AN ARRAY OF SORTED STRINGS INTERSPACED WITH SPACES:
USING BINARY SEARCH:
public class tester {

	public static void main(String[] args) {
       
	String s[]={"at","","","ball","","","", "", "baramoz","","","","bat","fig"};
	int low=0,high=s.length-1;
String val="bag";
   System.out.println(binarySearch(s,low,high,val));

	
}
	
	public static int binarySearch(String s[],int low,int high,String val)
	{
		
		int count=0,count1=0;
		int mid=(high+low)/2;
		
		if(high<low)
			return -1;
		

		  if(s[mid].isEmpty())
		    {
		    	for(int i=mid+1;i<high;i++)
		    	{
		    		 if(s[i].equals(""))
		    			 count++;
		    		 
		    		 else{
		    			 //System.out.println(count);
		    			 break;
		    		 }
		    	}
		    	for(int i=mid-1;i>=low;i--)
		    	{
		    		 if(s[i].equals(""))
		    			 count1++;
		    		 
		    		 else{
		    			 //System.out.println(count1);
		    			 break;}
		    	}
		    	
		    
		    	if(count<count1)
		    		mid=mid+(count+1);
		    	else
		          mid=mid-(count1+1);
		    }
	
		 
		
		   if(s[mid].equals(val))
				 return mid;
		 
		 
		   else if((s[mid].compareTo(val)<0))
		       return binarySearch(s,mid+1,high,val);
		
		    else 
		    	 return binarySearch(s,low,mid-1,val);
		    
	}
	
}
2ND PROGRAM:
public class tester {

	public static void main(String[] args) {
       
	String s[]={"at","","","ball","","","", "", "baramoz","","","","bat","fig"};
	int low=0,high=s.length-1;
String val="baramoz";
   System.out.println(binarySearch(s,low,high,val));

	
}
	
	public static int binarySearch(String s[],int low,int high,String val)
	{
		
		int count=0,count1=0;
		int mid=(high+low)/2;
		
		if(high<low)
			return -1;
		

		   if(s[mid].isEmpty())
			   
		   {
			   int left=mid-1;
			   int right=mid+1;
			   while(left>=low && right<=high)
			   {
				   
				   if(left<low && right >high)
					   return -1;
				   
				   else if(right<=high && !s[right].isEmpty())
				   {
					   mid=right;
				              break;
				   }
				   
				   
				   else if(left>=low && !s[left].isEmpty())
				   {
					   mid=left;
				           break;
				   }
				   
				   right++;
				   left--;
				   
				   
				 }
			   
			   
		   }
		
	
		 
		
		   if(s[mid].equals(val))
				 return mid;
		 
		 
		   else if((s[mid].compareTo(val)<0))
		       return binarySearch(s,mid+1,high,val);
		
		    else 
		    	 return binarySearch(s,low,mid-1,val);
		   
	   
	}
	
}
OUTPUT:8

PROGRAM TO FIND AN ELEMENT IN A DOUBLE ARRAY (M*N) WHERE ALL ROWS AND COLUMNS ARE SORTED IN ASCENDING ORDER:
O(MLOGN) SOLUTION:
		
public class tester {

	public static void main(String[] args) {
       
	
		int x[][]={{7,11,13},{8,32,64},{22,64,120},{56,86,122},{100,150,160}};
		int val=122;
		int res=0;
		int k=0;
		  int row[]=new int[x[0].length];
		  
		    for(int i=0;i<x.length;i++)
		    {k=i;
		    	
		    	for(int j=0;j<x[i].length;j++)
		    	{
		    		
		    		row[j]=x[i][j];
		    		
		    	}
		    	 res=binary_Search(row,0,row.length-1,val);
		    		if(res!=-1)
		    			 break;
		    		
		    }
		
		
		System.out.print("row" +k);
		System.out.print("column" + res);
	   
	}
	
	public static int binary_Search(int arr[],int low,int high,int val)
	{
		
		 int mid=(low+high)/2;
		 
		  if(high<low)
			  return -1;
		 
		 if(arr[mid]==val)
		   return mid;
		 
		
		  
		  
		  else if(val<arr[mid])
			 return  binary_Search(arr,low,mid-1,val);
		  
		  else if(val>arr[mid])
			return  binary_Search(arr,mid+1,high,val);
		  
		  
		  else
			  return-1;
		
	}
	
}
OUTPUT:
ROW :3, COLUMN :2	

METHOD TWO:BY COMAPRING WITH THE END OF THE START OF THE LAST COLUMN.
IF VAL>NUMBER THEN GO TO THE NEXT ROW.
IF VAL<NUMBER THEN GO THE PREVIOUS COLUMN.
DO THIS RECURSIVELY UNTIL THE NUMBER IS FOUND.
O(N)solution
public class tester {

	public static void main(String[] args) {
       
	
		int x[][]={{7,11,13},{8,32,64},{22,64,120},{56,86,122},{100,150,160}};
		int val=150;
		
		System.out.println(search(x,val,0,x[0].length-1));
		
		
		
		
	}
	
	
	
	public static boolean search(int x[][],int val,int row,int col)
	{
		if(col>=0 && row!=x.length)
		{
		
		
		if(x[row][col]==val)
		{   System.out.println("row:" +row +" "+"column:"+ col);
			return true;
		}
		
		
		else if(val>x[row][col])
		   return search(x,val,row+1,col);
		
		else if(val<x[row][col])
			return search(x,val,row,col-1);
		else
			return false;
		}
		else
		return false;
			
		
	}
}
	
OUTPUT:
row:4 column:1
true

C PROGRAM FOR POINTERS AND DYNAMIC MEMORY ALLOCATION:
#include<stdio.h>
#include<stdlib.h>

int main()
{
  int n;
    printf("enter the size:");
    scanf("%d",&n);
    int * A=(int*)calloc(n,sizeof(int));//same as(int*)malloc(n*sizeof(int))
int i,j;
     for(i=0;i<n;i++)
     {

         A[i]=i+1;
     }
     int *b=(int*)realloc(A,2*n*sizeof(int));


     for(j=0;j<2*n;j++){
          printf("%d\n",b[j]);

     }
}
output:n=3
1 2 3 -435345 -22424 -98847
 
GIVEN AN ARRAY OF INTEGERS WRITE A METHOD TO FIND THE INDICES M AND N SUCH THAT IF YOU SORTED THROUGH M & N THE ENTIRE
ARRAY WOULD BE SORTED:
eq:x[]={1,2,4,7,10,11,7,12,6,7,16,18,19};
output:m=3,n=9

crude method:
public class tester {

	public static void main(String[] args) {
   
		
	int x[]={1,2,4,5,16,6,7,3,9,13,14,15};
	int index=0;
	int m=0;
	int n=0;
	
	      for(int i=0;i<x.length-1;i++)
	      {
	    	  
	    	  if(x[i+1]<=x[i])
	    		  index=i+1;
	      }
	
	    System.out.println(x[index]);
	    
	       for(int j=index-1;j>=0;j--)
	       {
	    	   
	    	   if(x[j]>x[index])
	    		   m=j;
	       }
	       System.out.println(x[m]);
	       
	      sort(x,m,index);
	      for(int j=0;j<x.length;j++)
	    	 System.out.print(x[j]+" ");
	      
	      System.out.println();
	         
	      for(int k=x.length-1;k>0;k--)
	      {
	    	  
	    	  if(x[k-1]>x[k])
	    		  index=k-1;
	    	  
	      }
	      sort(x,index,x.length-1);
	      for(int j=0;j<x.length;j++)
	    	  System.out.print(x[j]+" ");
	         
	      
	
	}
	
	public static void sort(int x[],int low,int high)
	{
		int min;int pos=0;int temp=0;
		
		for(int j=low;j<high;j++)
		{
			min=x[j];
			
			   for(int i=j+1;i<=high;i++)
			   {
			       if(x[i]<min)
			       {
				       min=x[i];
			          pos=i;
			       }
			   }
			   if(min!=x[j]) // this condition ensures that if there is no element smaller than the current min then swap does not take place.
			   {
			   temp=x[j];
			   x[j]=min;
			   x[pos]=temp;
			   }
			   
		}
			 
			
   }
			
		
}
  
PROGRAM TO PRINT THE 2ND LARGEST ELEMENT IN AN ARRAY:
COMPLEXITY:O(n):

public class tester {

	public static void main(String[] args) {
   
		int x[]={3,1,5,6,23,112,930,21,16500};
		
		int max=x[0];
		int max2=0;
		int temp;
		for(int i=1;i<x.length;i++)
		{
			
			if(x[i]>max)
			{
				temp=max;
				max=x[i];
				max2=temp;
				
			}
			else
			{
				if(x[i]>max2)
					max2=x[i];
				
			}
			
		}
		System.out.println(max2);
		
		
}

}
OUTPUT:930

LINKED LIST IMPLEMENTATION:USING C LANGUAGE:

INSERT NODE AT THE BEGINING/NTH POSITION /DELETE AT NTH POSITION:

#include<stdio.h>
#include<stdlib.h>
void insert(int,int);
void print();

typedef struct node{
    int data;
    struct node* next;
    }node;

  node *head;
  node* temp1;
  int main()
  {
      int i,x,n,pos,del;
    printf("enter the number of elements:");
    scanf("%d",&n);

      for(i=0;i<n;i++)
      {
        printf("enter the element: ");
         scanf("%d",&x);
          printf("enter the position: ");
         scanf("%d",&pos);
         insert(x,pos);
         print();
      }

        printf("enter the numbers you want to delete:");
             scanf("%d",&del);
         for(i=0;i<del;i++)
         {
         printf("enter the position you want to delete:");
         scanf("%d",&pos);
         delete(pos);
         print();
         }


  }
void insert(int x,int pos)
  {  int i;
      node *temp=(node*)malloc(sizeof(int));
         (*temp).data=x;
         if(pos==1){  //INSERT AT FIRST POSITION
          (*temp).next=head;
            head=temp;
            }
         else{  //INSERT AT NTH POSITION
         node *temp2=head;
          for(i=1;i<pos-1;i++)
          {
              temp2=(*temp2).next;
          }
           (*temp).next=(*temp2).next;
            (*temp2).next=temp;
         }

  }
 void print()
 {
     node * temp1=head;
     printf("the list is:");
     while(temp1!=NULL)
     {
         printf("%d",(*temp1).data);
         temp1=(*temp1).next;

      }

    printf("\n");
 }
void delete(int pos)
{int i,j;
         node *temp1=head;
       if(pos==1) //DELETE FIRST ELEMENT
       {
         head=(*temp1).next;

       }
       else{ //DELETE NTH ELEMENT
            for(i=1;i<pos-1;i++)
                temp1=(*temp1).next;

                node *temp2=(*temp1).next;

                     (*temp1).next=(*temp2).next;

            }

}

REVERSE A LINK LIST:

#include<stdio.h>
#include<stdlib.h>
void insert(int,int);
void print();
void delete(int);
void reverse();
typedef struct node{
    int data;
    struct node* next;
    }node;

  node *head;
  node* temp1;
  int n;
  int main()
  {
      int i,x,pos,del;
    printf("enter the number of elements:");
    scanf("%d",&n);

      for(i=0;i<n;i++)
      {
        printf("enter the element: ");
         scanf("%d",&x);
          printf("enter the position: ");
         scanf("%d",&pos);
         insert(x,pos);
         print();
      }

    reverse();
    print();


  }
void insert(int x,int pos)
  {  int i;
      node *temp=(node*)malloc(sizeof(int));
         (*temp).data=x;
         if(pos==1){
          (*temp).next=head;
            head=temp;
            }
         else{
         node *temp2=head;
          for(i=1;i<pos-1;i++)
          {
              temp2=(*temp2).next;
          }
           (*temp).next=(*temp2).next;
            (*temp2).next=temp;
         }

  }
 void print()
 {
     node * temp1=head;
     printf("the list is:");
     while(temp1!=NULL)
     {
         printf("%d",(*temp1).data);
         temp1=(*temp1).next;

      }

    printf("\n");
 }
void reverse()
{int j;

    node * prev=NULL;
      node  
      node * next;

       while(temp1!=NULL)
       {
          next=(*temp1).next;
          (*temp1).next=prev;
          prev=temp1;
          temp1=next;
        }
        head=prev;
}
INPUT:245
OUTPUT:452

QUICKSORT:PARTITION ALGORITHM:Last element as pivot

public class tester {

	public static void main(String[] args)
	{
		int x[]={3,7,8,5,2,1,9,5,4},pivot=x.length-1;
		
		int i=0,j=x.length-2;
		
		while(i<=j)
		{
			
			if(x[i]>x[pivot])
			{
				swap(x,i,j);
			System.out.println(x[i] + " "+ x[j]);
				swap(x,j,pivot);
				System.out.println(x[j] + " "+ x[pivot]);
				j--;
				pivot--;
				
		    }
			else
				i++;		
		}
		  for(int m=0;m<x.length;m++)
			  System.out.print(x[m]+" ");
		 
		
     }
	
	
	public static void swap(int x[],int a,int b)
	{
		
		int temp=x[a];
		 x[a]=x[b];
		 x[b]=temp;
			
		
	}
}
OUTPUT:
3 1 2 4 5 8 9 5 7

RADIX SORT:
public class tester {

	public static void main(String[] args)
	{
		
		int x[]={170,45,75,90,802,24,2,86};
		for(int i=0;i<3;i++)
		{
		CountingSort(x,i);
		}
		
	}
	public static void CountingSort(int x[],int index)
	{
		int count[]=new int[10];
		int b[]=new int[x.length];
		for(int i=0;i<x.length;i++){
			 
			count[(x[i]/(int)(Math.pow(10,index)))%10]=count[(x[i]/(int)(Math.pow(10,index)))%10]+1;
		}
		
		for(int j=1;j<count.length;j++)
			count[j]=count[j]+count[j-1];
		
		for(int i=b.length-1;i>=0;i--)
		{
			b[count[(x[i]/(int)(Math.pow(10,index)))%10]-1]=x[i];
			count[(x[i]/(int)(Math.pow(10,index)))%10]--;
				
		}
		
		for(int k=0;k<b.length;k++)
			  x[k]=b[k];
		
		
		    for(int j=0;j<x.length;j++)
		    	System.out.print(x[j]+" ");
		    
		    System.out.println(" ");
			
		
		
	}
	
	
}
OUTPUT:
170 90 802 2 24 45 75 86  
802 2 24 45 170 75 86 90  
2 24 45 75 86 90 170 802  

REVERSE AN ARRAY:
public class tester {

	public static void main(String[] args)
	{
       int x[]={6,2,1,4,9,3,0};
      for(int i=0;i<(x.length)/2;i++)
      {
    	  int a=x[i];
    	   x[i]=x[x.length-1-i];
    	   x[x.length-1-i]=a;
    	  
    	  
    	  
      }
      for(int j=0;j<x.length;j++)
    	  System.out.print(x[j]+" ");
}
}
OUTPUT:
0 3 9 4 1 2 6	

ADD NUMBERS IN AN ARRAY USING RECURSION:
public class tester {

	public static void main(String[] args)
	{
       int x[]={4,1,2,3,6,5};
         int n=x.length-1;
       int k=sum(x,n);
         System.out.print(k);
       
       
       
    }
	public static int sum(int x[],int n)
	{
		if(n==0)
			return x[n];
		else
			return x[n]+sum(x,n-1);
			
	}
		
}
OUTPUT:
21

GIVEN A NUMBER PRINT A PATTERN USING RECURSION:
eq n=16:
print: 16 11 6 1 -4 1 6 11 16
n=10
print:10 5 0 5 10


package akash;

import java.io.*;
 
public class test2{
    
	public static void main(String args[])  {
		
		int n=16;
		int val=n;
		int k=-5;
		print(n,k,val);
}

	public static void print(int n,int k,int val) {
		
		 if(n>val)
			 return;
		 if(n<=0)
			k=Math.abs(k);
		 
		 System.out.print(n +" ");
		 print(n+k,k,val);
	}
}

OUTPUT:5 10 0 5 10

MEDIAN OF TWO SORTED ARRAYS:
public static void main(String args[])
	    {
            int x[]={3,5,9,11};
            int y[]={0,2,6,10};
            
            int arr[]=new int[x.length+y.length];
            int mid=(x.length+y.length-2)/2;
            System.out.println(mid);
            
            int i=0,j=0,k=0;
            while(i<x.length && j<y.length && k<=mid)
            {
            	
            	if(x[i]<y[j])
            	{
            		 arr[k]=x[i];
            	    i++;
            	}
            	
            	else
            	{
            		arr[k]=y[j];
            		j++;
            	}
            	k++;
            	
            	
            	
            	
            }
            
          
            System.out.println("median is:"+ arr[k-1]);
            
	    }	
	    	
	    	
	    	
	}
OUTPUT:5

FIND MISSING NUMBER IN AN AP IN O(logn):
 public static void main(String args[])
	    {
            int x[]={2,6,8,10,12,14,16,18};
             
            int mid=(x.length-1)/2;
            int k=search(x,mid);
            System.out.println(k);
            
	    	
	    	
	}
	    public static int search(int x[],int mid)
	    {
	    	if(x[mid+1]-x[mid]!=2)
	    			return x[mid]+2;
	    	
	    	else if(x[mid]-x[mid-1]!=2)
	    		return x[mid]-2;
	    	
	    	
	    else if(x[mid]==x[0]+mid*2)//checking whether the left of mid is in AP
	    		return search(x,mid+1);
	    	
	    	else 
	    		return search(x,mid-1);
	    	
	    	
	    	
	    	  
	    	
	    	
	    	
	    }
}
OUTPUT:4


COUNT THE NUMBER OF ZEROES:
public class recursiv_insertionsort {

	
	
	    public static void main(String args[])
	    {
            int x[]={1,1,1,0,0,0};
            int count=0;
          
               int m=zeroes(x,x.length);
           System.out.println(m);
	    	  
	    	
	    	
	    	
	    }
	    public static int search(int x[],int low,int high)
	    {    
	    	  if(low<=high)
	    	  {
	    		     int mid=(low+high)/2;
	    		     
	    		        if(mid==0 || x[mid-1]==1 && x[mid]==0)
	    		        	return mid;
	    		        
	    		        else if(x[mid]==1)
	    		        	 return search(x,mid+1,high);
	    		        else
	    		        	return search(x,low,mid-1);
	    		        
	    	  }
	    	  else
	    		  return -1;
	    		  
	    	  
	    	
	   
	    	
	    }
     public static int zeroes(int x[],int n)
     {
    	 int k=search(x,0,x.length-1);
    	    if(k==-1)
    	    	return -1;
    	    
    	    else
    	    	return n-k;
    	 
    	 
     }
}
OUTPUT:3


FIND A NUMBER THAT OCCURS A ODD NUMBER OF TIMES IN AN ARRAY:O(n)

  public static void main(String args[])
	    {
            int x[]={1,2,3,1,3,2,3,2,3};
            int count=0;
         
            for(int i=0;i<x.length;i++)
            {
            	count=count^x[i];
            	
            	
            }
            System.out.println(count);
	    }
output:2
This program uses the XOR opertaor.In XOR if both numbers are same we get 0 and the XOR 
of a number x with 0 is he number x.


INHERITANCE IN JAVA:ILLUSTRATES THE USE OF 'super'KEYWORD.

package helloworld;

public class Animal {

	  int size;
	public void eat()
	{
		System.out.println("eat food");

	}
	public void prey()
	{
		System.out.println("hunt for food");
	}

}


public class Dog extends Animal {


	public void eat()//method overriding
	{
		super.eat();// when we use super then jvm first goes to the inherited 
                                eat() method in the superclass then it comes to its own eat()
		System.out.println("eat grass");
	}
	public void setSize(int size)
	{    
		if(size>20)
			this.size=size;
		else
			this.size=0;

	}
	public int getSize()
	{
		return size;
	}

}


public class driver {

	public static void main(String[] args) {
		Dog d=new Dog();
		d.setSize(25);
		System.out.println(d.getSize());
		d.eat();
		d.prey();

	}

}
OUTPUT:
25
eat food
eat grass
hunt for food

POLYMORPHISM:
Animal obj=new Dog()// if the object that the reference variable is pointing to extends the refe variable type then
polymorphism is used as shown above.

package helloworld;

public class Animal {

	  int size;
	public void eat()
	{
		System.out.println("eat food");

	}
	public void prey()
	{
		System.out.println("hunt for food");
	}

}



package helloworld;

public class Dog extends Animal {


	public void eat()//method overriding
	{
		System.out.println("eat grass");
	}
	public void setSize(int size)
	{    
		if(size>20)
			this.size=size;
		else
			this.size=0;

	}
	public int getSize()
	{
		return size;
	}

}
package helloworld;

public class cat extends Animal{

	public void eat()
	{
		System.out.println("cat eats bullcrap");
	}

}
package helloworld;

public class driver {

	public static void main(String[] args) {
		Animal[] obj=new Animal[2];
		obj[0]=new Dog();//POLYMORPHISM
		obj[1]=new cat();
		for(int i=0;i<obj.length;i++)
		{
			obj[i].eat();
			obj[i].prey();
		}
	}

}
OUTPUT:
eat grass
hunt for food
cat eats bullcrap
hunt for food

POLYMORMHISM USING POLYMORPHIC ARGUMENTS:
package helloworld;

public class Animal {


	public void makeNoise()
	{
		System.out.println("make animal noise");

	}


}

public class Dog extends Animal {

	public void makeNoise()
	{
		System.out.println("bark");
		
	}

}

public class cat extends Animal{

	public void makeNoise()
	{
		System.out.println("meow");
	}

}
public class Pet {

	public void makeSound(Animal d)
	{
		d.makeNoise();
	}


}
public class driver {

	public static void main(String[] args) {
		Dog d=new Dog();
		cat c=new cat();
		Pet p =new Pet();
		p.makeSound(d);
		p.makeSound(c);
	}

}
OUTPUT:
bark
meow

METHOD OVERLOADING:
package akash;

public class example {

	public static void main(String[] args) {
		example obj=new example();
		obj.beTrouble(6, "akash");
		System.out.println(obj.beTrouble(6, 3));



	}


	public void beTrouble(int x,String y)//method overloading
	{
		System.out.println("the integer is:"+x +"and the string is:" +y);
	}
	public int beTrouble(int y,int x)
	{
		return x+y;
	}

}
OUTPUT:
the integer is:6and the string is:akash
9

CONSTRUCTOR CHAINING:SUPERCLASS CONSTRUCTORS
package helloworld;

public class Animal {


	public Animal()
	{
		System.out.println("Animal:superclass");

	}


}
public class Dog extends Animal {

	public Dog()
	{
		System.out.println("Dog:subclass1");
		
	}

}

public class Pet extends Dog {
int size;
  public Pet()
  {
	  System.out.println("Pet:subclass2");
  }

public static void main(String...args){
  Pet obj=new Pet();
}

}

Animal:superclass
Dog:subclass1
Pet:subclass2

PARAMETERIZED SUPER:
package helloworld;

public class Animal {
	private int size;

	public Animal(int size)
	{
		this.size=size;
	}
	public int getSize()
	{
		return size;
	}

}
public class Dog extends Animal {

	public Dog(int measure)
	{
		super(measure);//parameterized super calls the overloaded superclass constructor.
    }

}
public class driver {

	public static void main(String[] arg){
	  Dog obj=new Dog(25);
	  System.out.println(obj.getSize());
	  

	}

}
OUTPUT:
25

USE OF THIS KEYWORD:
package helloworld;

public class Animal {
	private float size;

	public Animal(int length)
	{  this(length+30.5f);//This keyword is used to call other overloaded constructors in the same class.

	}
	public Animal(float size)
	{
		this.size=size;
	}

	public float getSize()
	{
		return size;
	}
	
}
package helloworld;

public class Dog extends Animal {
   
	
	public Dog(int measure)
	{
		super(measure);
    }

}
public class driver {

	public static void main(String[] arg){
	  Dog obj=new Dog(25);
	  System.out.println(obj.getSize());
	  

	}

}
OUTPUT:
55.5

PROGRAM TO FIND THE LARGEST STRING IN AN ARRAY OF STRINGS:
package akash;

public class example {

	public static void main(String[] args) {

		String[] s={"palindrome","succint","supercalifrigilistic","armstrong"};
		int max=0;

		for(int i=0;i<s.length;i++)
		{
			if(s[i].length()>s[max].length())
				max=i;

		}
		System.out.println(s[max]);


	}

}
OUTPUT:
supercalifrigilistic

USE OF SUBSTRING:
string.substring(int beginindex)-beginindex is inclusive
string.substring(int beginindex,int endindex)-end index is exclusive

public class problem14 {

	public static void main(String[] args) {
		String g="akash";
		System.out.println(g.substring(2));
		System.out.println(g.substring(2,4));
	  
		

	}

}
OUTPUT:
ash
as

IMPLEMENT FUNCTIONALITY OF THESE INBUILT FUNCTIONS ON YOUR OWN:
charAt()
import java.util.Scanner;

//implementing charAt using own logic
public class problem142 {

	public static void main(String[] args) {
		String s="akash";
		Scanner obj=new Scanner(System.in);
		System.out.println("enter the position you want");
		int k=obj.nextInt();
		problem142 obs=new problem142();
		String x=obs.charExtract(s,k);
		System.out.println(x);
		obj.close();


	}
	public String charExtract(String s,int k)
	{
		if(k>=s.length())
			return "exceeded string length";
		else
			return s.substring(k,k+1);
	}

}
OUTPUT:
enter the position you want
3
s

//implementing replace() using own logic:
import java.util.Scanner;
public class problem143 { //implementing replace() function using own logic

	public static void main(String[] args) {
		String s="akash is great";
		char c[]=s.toCharArray();
		Scanner in=new Scanner(System.in);
		System.out.println("enter the character you want replaced:");
		char m=in.next().charAt(0);
		System.out.println("enter the character you want to insert");
		char h=in.next().charAt(0);

		problem143 obj=new problem143();
		obj.myReplace(c,m, h);

		s=String.valueOf(c);
		System.out.println(s);



	}
	public void myReplace(char []c,char m,char h){

		for(char k=0;k<c.length;k++)
		{
			if(c[k]==m)
				c[k]=h;

		}
	}

}
OUTPUT:
enter the character you want replaced:
a
enter the character you want to insert
r
rkrsh is grert

//implement substring() using my own logic:
import java.util.Scanner;
//program to implement substring(int beginIndex) with my own logic
public class problem144 {

	public static void main(String[] args) {
		String s="akash";
		Scanner obj=new Scanner(System.in);
		System.out.println("enter the position you want");
		int x=obj.nextInt();
		try{
		char c[]=new char[s.length()-x];;
		int k=0;
		subString(c, x, k, s);
		s=new String(c);
		System.out.println(s);
		}
		catch(Exception e)
		{
			System.out.println("index out of bounds");
		}

	}
	public static void subString(char c[],int x,int k,String s)
	{
		for(int i=x;i<s.length();i++)
		{
			c[k]=s.charAt(i);
			k++;
		}	
	}
}
OUTPUT:
enter the position you want
2
ash

THIS KEYWORD:
public class example1 {

	public example1()
	{   
	System.out.println("no arg");
	}
	public example1(int a,int b)
	{   this(a+b);
	System.out.println("2 arg");
	}
	public example1(int a)
	{   this();
		System.out.println("1 arg");
	}

	public static void main(String[] args) {

		example1 obj=new example1(3,5);

	}

}
OUTPUT:
no arg
1 arg
2 arg
USE OF STATIC BLOCKS:
package akash;

public class example1 {

	static int x;
	static { //static blocks are executed before main() and are executed in the order they are written.
		x=32;
		System.out.println(x);

	}
	public static void main(String[] args) {

		  x++;
                 System.out.println(x);
		 show();
	}
	public static void show()
	{
		x++;
		System.out.println(x);
	}
	static
	{
		x++;
		System.out.println(x);
	}

}
OUTPUT:
32
33
34
35

RUNTIME POLYMORPHISM:
package akash;

class Cricket1 {
	public void type(){
		System.out.println("Indoor & outdoor");
	}
 }
public class example1 extends Cricket1{
	public void type(){
		System.out.println("Method Overridden");
	}
	public void show(){
		System.out.println("hello");
	}
	public static void main(String args[]){
		Cricket1 ck=new example1();//creating parent ref variable pointing to child class(this ref var can access only those methods of child which
		ck.type();                   are also present in parent.
		//ck.show();//this will show compile time error as method show is not defined in parent class.
                     so using runtime polymorphism you can access only those methods of child which are defined in the 
                     parent class.
	}
}
OUTPUT:
Method overridden

FINALIZE() AND GARBAGE COLLECTOR:
public class example1{
	
	public static void main(String args[]){
		example1 obj=new example1();
		obj=null;
		System.gc();
	}
		
		protected void finalize()//if we want to do some work before our object is trashed by the GC we use 
                                           finalize.It is declared protected inside a class.
		{   
			System.out.println("garbage collector");
		}
		
}
OUTPUT:
garbage collector

THIS ILLUSTRATES THE USE OF GC
public class example1{
	
	public static void main(String args[]){
		example1 obj=new example1();
		obj.show();
	         obj=null;
		System.gc();
		obj.show();
	}
		public void show()
		{
			System.out.println("show");
		}
		protected void finalize()
		{   
			System.out.println("garbage collector");
		}
		
	}

OUTPUT:
show
garbage collector
Exception in thread "main" java.lang.NullPointerException
	at akash.example1.main(example1.java:11)


ABSTRACT CLASS:
package akash;
//its a way of defining a generic function which can be implemented in diferent ways.
cannot achieve 100% abstraction.
abstract class parent{ 
      int x;//can have member variables
	abstract void area(int radius);//may or may not contain abstract methods

	public void print()//can have normal methods
	{
		System.out.println("hello");
	}
	parent()//can have constructors
	{
		System.out.println("abstract constructor");
	}

}
public class example1 extends parent{//this class must implement the abstract method or declare itself abstract as well.

	void area(int x )
	{
		System.out.println(x);
	}

	public static void main(String args[]){
		parent obj=new example1();//cannot create instance of abstract class.
		obj.area(20);
		obj.print();
	}//abstract classes can have static methods and variables which can be accessed using classname.method()/variable
}
OUTPUT:
abstract constructor
20
hello

INTERFACE:
Used to achieve complete abstraction and multiple inheritance.
package akash;

interface Moveable{
	 int avg_speed=40;//any declaration is final
	 void move();//will have methods which are abstract.
	
}
public class example1 implements Moveable{

	public void move()//an instantiable class must implement all methods inside an interface.An abstract class may
                          not implement all methods.
	{
		System.out.println("i am moving");
	}

	public static void main(String args[]){
	example1 obj=new example1();
		obj.move();

	}
}
OUTPUT:
i am moving

package akash;

interface Moveable{
	 int avg_speed=40;
	 void move();
	
}
abstract class example1 implements Moveable{
	//an abstract class may not implement all abtract methods of the interface.
	public static void main(String args[]){
	XX obj=new XX();
	obj.move();

	}
}
 class XX extends example1{//this class must implement the abtract method.
	public void move()
	{
		System.out.println("move");
	}
 }

OUTPUT:
move

HOW TO ACHIEVE MULTIPLE INHERITANCE USING INTERFACE;
package akash;

interface Moveable{
	 int avg_speed=40;
	 boolean move();
	
}
interface NonMoveable{
	boolean nonMove();
}
 class example1 implements Moveable,NonMoveable{
	
	 public boolean move()
	 {
		 return true;
	 }
	 public boolean nonMove()
	 {
		 return false;
	 }
	 
	 
	public static void main(String args[]){
	example1 obj=new example1();
	System.out.println(obj.move() + " "+ obj.nonMove());
	}
}
 
OUTPUT:
true false

THE toString() METHOD:
Returns the string object representation of a primitive type number object.
package akash;
import java.util.Date;

public class example1{
	
	public static void main(String...args)
	{
		Integer x=10;
		System.out.println(x.toString());
		System.out.println(Integer.toString(12));
	}
}
 
OUTPUT:
10
12

ARRAYLIST:
import java.util.ArrayList;

public class dog{
	public static void main(String...args)
	{int total=0;
		ArrayList<Integer>grades=new ArrayList<Integer>();
		grades.add(98);
		grades.add(79);
		grades.add(48);
		for(int i=0;i<grades.size();i++)
		{
			total+=grades.get(i);
		}
	System.out.println(total/grades.size());	
}
}
OUTPUT:
75


import java.util.ArrayList;

public class dog{
	public static void main(String...args)
	{	
		ArrayList<Integer>names=new ArrayList<Integer>();
		for(int i=1;i<10;i++)
			names.add(i);
		change(names);
		display(names);
    }

	private static void display(ArrayList<Integer> names) {
		for(int j=0;j<names.size();j++)
			System.out.print(names.get(j)+" ");
	}

	private static void change(ArrayList<Integer> names) {
		for(int i=0;i<names.size();i++)
			names.set(i, names.get(i)+5);//set is used to change the content of array list
		
	}
}
OUTPUT:
6 7 8 9 10 11 12 13 14 


GENERATIN RANDOM NUMBERS:
public class dog{
	public static void main(String...args)
	{	int number;
	  Random ran=new Random(System.currentTimeMillis());
	  number=ran.nextInt(100);
	  System.out.println(number);
	  
	}	
}

FILLING ARRAYLIST USING RANDOM NUMBERS:
import java.util.ArrayList;
import java.util.Random;

public class dog{
	public static void main(String...args)
	{	
	  Random ran=new Random(System.currentTimeMillis());
	  ArrayList<Integer>arr=new ArrayList<Integer>();
	  for(int i=0;i<10;i++)
	  {
		  arr.add(ran.nextInt(100));
	  }
	  for(int i=0;i<arr.size();i++)
		  System.out.println(arr.get(i));
	}	
}


SEARCHING AN ARRAYLIST:
import java.util.ArrayList;
import java.util.Random;

public class dog{
	public static void main(String...args)
	{ int x=5;
	ArrayList<Integer>list=new ArrayList<Integer>();
	Random ran=new Random(System.currentTimeMillis());
	for(int i=0;i<10;i++)
	{
		list.add(ran.nextInt(10));
	}
	for(int i=0;i<list.size();i++)
	{
		if(list.get(i)==x)
		{
			System.out.println("element found at position:"+i);
			x=0;
			break;
		}
	}
	if(x==5)
		System.out.println("element not found");
	}	
}


SORTING AN ARRAYLIST:
public class dog{
	public static void main(String...args)
	{ int x=5;
	ArrayList<Integer>list=new ArrayList<Integer>();
	Random ran=new Random(System.currentTimeMillis());
	for(int i=0;i<10;i++)
	{
		list.add(ran.nextInt(10));
	}
	for(int i=0;i<list.size()-1;i++)
	{  
		int j=i;
		while(j>=0 && list.get(j)>list.get(j+1))//insertion sort
		{
			int temp=list.get(j);
			list.set(j, list.get(j+1));
			list.set(j+1, temp);
			j--;
		}
	}
	for(int j=0;j<list.size();j++)
		System.out.print(list.get(j));

	}

}
OUTPUT:
0123377778


FINDING MAX NUMBER IN AN ARRAY LIST:
public class dog{
	public static void main(String...args)
	{ 
		ArrayList<Integer>arr=new ArrayList<Integer>();
		arr.add(25);
		arr.add(35);
		arr.add(89);
		arr.add(98);
		arr.add(32);
		int max=arr.get(0);
		for(int i=1;i<arr.size();i++)
		{
			if(arr.get(i)>max)
				max=arr.get(i);
		}
		System.out.println("max element is:"+max);
	}
}
OUTPUT:
max element is 98

FINDING PALINDROME NO's IN AN ARRAYLIST:
public class dog{
	public static void main(String...args)
	{ int n,sum,rem;
	ArrayList<Integer>arr=new ArrayList<Integer>();
	arr.add(757);
	arr.add(676);
	arr.add(899);
	arr.add(36);
	arr.add(78);

	for(int i=0;i<arr.size();i++)
	{ n=arr.get(i);
	sum=0;
	while(n!=0)
	{
		rem=n%10;
		sum=sum*10 +rem;
		n=n/10;
	}
	if(sum==arr.get(i))
		System.out.println("the no:"+arr.get(i)+" "+"is palindrome");
	}

	}
}
OUTPUT:
the no:757 is palindrome
the no:676 is palindrome



SELECTION SORT USING ARRAYLIST:
public class test2 {

	public static void main(String...args)
	{   
		ArrayList<Integer>x=new ArrayList<Integer>();
		for(int i=0;i<5;i++)
		{
			Scanner s=new Scanner(System.in);
			System.out.println("Enter the element :");
			x.add(s.nextInt());
		}

		for(int i=0;i<x.size()-1;i++)
		{
			int min=i;
			for(int j=i+1;j<x.size();j++)
			{
				if(x.get(j)<x.get(min))
					min=j; 
			}
			int temp=x.get(i);
			x.set(i,x.get(min));
			x.set(min,temp);	
		}

		for(int i=0;i<x.size();i++)
			System.out.print(x.get(i)+" ");
	}

}



PROGRAM TO REVERSE A STRING:
public class dog{
	public static void main(String...args)
	{ 
		String str="akash is a good boy.";
		String rev="";
		for(int i=str.length()-1;i>=0;i--)
			rev=rev+str.charAt(i);

		System.out.println(rev);
	}
}
OUTPUT:
.yob doog a si hsaka


PROGRAM TO SEARCH A GIVEN STRING IN A PARAGRAPH AN FIND ITS COUNT:
/*find the number of times a string appears in a sentence and find its count*/
public class problem10 {

	public static void main(String[] args) {
		Scanner obj=new Scanner(System.in);
		System.out.println("enter the paragraph");
		String s=obj.nextLine();
		System.out.println("enter the string you want to search:");
		String k=obj.nextLine();
		String s2="";
		int count=0;
		for(int i=0;i<=s.length();i++)
		{
			if(i!=s.length()&&s.charAt(i)!=32)
			{
				s2=s2+s.charAt(i);

			}

			else 
			{if(s2.equals(k))
				count++;

			s2="";
			}

		}
		if(count==0)
			System.out.println("word not in sentence");
		else
			System.out.println("the word:"+k +" " +"occurs" +" "+ count+ " " + " "+"times");

	}

}


PROGRAM TO IMPLEMENT split() FUNCTION IN OWN LOGIC:
I have implemented split(char c,int k) not split(string c,int k):

public class problem12 {

	public static void main(String...args)
	{   
	
		String str="welcome-to-tutorialspoint.com";
		Scanner obj=new Scanner(System.in);
		System.out.println("enter the string at which you want to split:");
	    char c=obj.next().charAt(0);
		//String m=obj.nextLine();
	    System.out.println("enter the limit:");
	    int k=obj.nextInt();
	    problem12 obj1=new problem12();
	    obj1.split(c, k, str);
		
	}
	
	
	public void split(char c,int k,String str)
	{   int x=1;
		int pos=0;
		String s="";
		for(int i=0;i<str.length()-2;i++)
		{     pos=i;
              if(x<k)
              {  
			     if(str.charAt(i)!=c){
				    s=s+str.charAt(i);
				
			       } 
			     else{
				   System.out.println(s);
				   s="";
				   x++;
			    }
              }
              else
            	  break;
           

		}
		System.out.println(str.substring(pos));
	}
}
enter the string at which you want to split:
to
enter the limit:
2
welcome-
o-tutorialspoint.com


PROGRAM TO FIND THE SECOND REPEATING CHARACTER IN A STRING:
eg:java programming-r is the second repeating character-brute force solution
public class test2 {
	
    public static void main(String a[]) {
	test2 obj=new test2();
	String s=" java pkopgramming";
	char[] c=s.toCharArray();
	int count=0;
	char x=' ';
	for(int i=0;i<c.length-1;i++)
	{    
		 if(x!=c[i])
		 {
		for(int j=i+1;j<c.length;j++)
		{
			if(c[i]==c[j])
			{   x=c[i];
				count++;
				break;
			}
		}
		 }
		 if(count==2)
		 {  System.out.println(c[i]);
			 break;
		 }
		
	}
	
    }
}
OUTPUT:
the second repeating character is:
p


PROGRAM TO FIND DUPLICATED WORDS IN A PARAGRAPH:
public class example1{
	
		public static void main(String[] a) {
		 String s="akash is gud is akash";
	      ArrayList<String>ar=new ArrayList<>();
	      ar.add("akash");
	      ar.add("is");
	      ar.add("gud");
	      ar.add("is");
	      ar.add("akash");
		  for(int i=0;i<ar.size()-1;i++)
		  {
			  for(int j=i+1;j<ar.size();j++)
			  {
				  if(ar.get(i).equals(ar.get(j)))
				  {
					  System.out.println("duplicate word:"+ar.get(i));
				  }
			  }
		  }	 
	}

}
OUTPUT:
duplicate words are:
akash is

O(N)solution
public class test2 {
	
    public static void main(String a[]) {
     Scanner obj=new Scanner(System.in);
     System.out.println("enter the string:");
     String s=obj.nextLine();
	String[] arr=s.split(" ");
	java.util.Arrays.sort(arr);
	
	 String s2="";
	 System.out.println("duplicate words are:");
	 for(int i=0;i<arr.length-1;i++)
	 {
		  if(!s2.equals(arr[i]))
		  {
			   if(arr[i].equals(arr[i+1]))
			   {
				   System.out.println(arr[i]);
				   s2=arr[i];
			    
		        }
	       }
    }
}
}





PROGRAM TO REMOVE DUPLICATE ELEMENTS IN AN ARRAY WHILE SORTING IT USING COUNTING SORT:
import java.io.*;
import java.util.*;

import org.omg.Messaging.SyncScopeHelper;
/* Program to remove duplicate elements and sort the array*/
public class test2 {
	  
	 public static void main(String a[]) throws IOException
	 {  
		 int x[]={3,4,3,2,1,0,4,2,3,600,80,12,311,123};
		
	     int count[]= new int[max(x)+1];
	     int lengthNew=0;
		 
		for(int i=0;i<x.length;i++)
		{
			  if(count[x[i]]==1)
			  {   lengthNew++;
				  continue;
			  }
			  else
				  count[x[i]]++;	
		}
		for(int i=1;i<count.length;i++)
			count[i]=count[i]+count[i-1];
		
		int b[]= new int[x.length-lengthNew];
		for(int i=0;i<x.length;i++)
		{
			b[count[x[i]]-1]=x[i];
		}
		for(int i=0;i<b.length;i++)
			System.out.print(b[i]+" ");
	 }

	 public static int max(int[] x) {
		int maxEl=x[0];
		
		for(int i=1;i<x.length;i++)
		{
			if(x[i]>maxEl)
				maxEl=x[i];
		}
		 
		return maxEl;
		
	}
	 
}
OUTPUT:
0 1 2 3 4 12 80 123 311 600 



PROGRAM TO COUNT DUPLICATE ELEMENTS IN O(n)://add(integer) returns true if the element is not already present
public class test2 {
	  
	 public static void main(String a[]) 
	 {  
		 int x[]={3,2,1,2,2,3,2,2,3,1,1,1};
		  HashSet<Integer> hs= new HashSet<>();
		  int count[]= new int[4];
		  for(int i=0;i<x.length;i++)
		  {
			  if(!hs.add(x[i]) && count[x[i]]<1)
			  {
				  System.out.println("duplicate elements:"+x[i]);
				  count[x[i]]++;
			  }
					  
		  }
		  System.out.println(hs);
}
}
OUTPUT:


PROGRAM TO FIND THE FIRST REPEATED ELEMENT:brute force

public class test2 {
	  
	 public static void main(String a[]) 
	 {  
		 int x[]={3,9,2,0,2,1,6,0};
		 int flag=0;
		 for(int i=0;i<x.length-1;i++)
		 {   if(flag==0)
		 {
			 for(int j=i+1;j<x.length;j++)
			 {
				 if(x[i]==x[j])
				 {
					 System.out.println("the first repeated element is:"+x[i]);
					 flag++;
					 break;
				 }
			 }
		 }
		 else
			 break;
			 
		 }		 
}
}
OUTPUT:
The first repeated element is 2



FIND TWO ELEMENTS WITH THE MINIMUM SUM:
public class test2 {
	  
	 public static void main(String a[]) 
	 {  
		int x[]={1,60,-10,70,-80,85};
		int minSum=100000;
		int sum=0;
		int m=0;
		int k=0;
		for(int i=0;i<x.length-1;i++)
		{     m=i;
			for(int j=i+1;j<x.length;j++)
			{
				sum=x[i]+x[j];
				
				if( Math.abs(sum)<minSum)
				{
					minSum=Math.abs(sum);
					 k=j;
				}
			}
		}
		System.out.println(minSum +" "+x[m]+" "+x[k]);
		
}
}
OUTPUT:
5 -80 85




PROGRAM TO FIND THE COUNT OF DUPLICATE ELEMENTS USING HASHTABLES:
import java.util.Hashtable;
import java.util.Enumeration;

public class test2 {

	public static void main(String args[]) {

		Hashtable<Integer,Integer> ht= new Hashtable<>();
		int x[]={3,2,1,2,2,3,1,9};
		Enumeration<Integer> emKey;
		for(int i=0;i<x.length;i++)
		{ int flag=0;
			emKey=ht.keys();
			while(emKey.hasMoreElements())
			{
				int k=emKey.nextElement();
				if(k==x[i])
				{
					ht.replace(x[i], ht.get(x[i])+1);
					flag++;
					break;
				}
				
			}
			if(flag==0)
				ht.put(x[i], 1);	
		}
       System.out.println(ht);	
	}
}
OUTPUT:
{9=1, 3=2, 2=3, 1=2}



PROGRAM TO SWAP EDGE ELEMENTS OF AN N*N ARRAY:
public class sample{
	public static void main(String args[]) {
		char x[][]={{'a','b','c','d'},{'e','f','g','h'},{'i','j','k','l'},{'m','n','o','p'}};
		int top=0;
		int bottom=x.length-1;
		int left=0;
		int right=x.length-1;
		
		while(top<bottom)
		{
			char topLeft=x[top][left];
			char topRight=x[top][right];
			char bottomRight=x[bottom][right];
			char bottomLeft=x[bottom][left];
			
			x[top][right]=topLeft;
			x[bottom][right]=topRight;
			x[bottom][left]=bottomRight;
			x[top][left]=bottomLeft;	
			
			
			top++;
			bottom--;
			left++;
			right--;
		}
	
	for(int i=0;i<x.length;i++)
	{
		for(int j=0;j<x[i].length;j++)
			System.out.print(x[i][j]+" ");
		
		System.out.println();
	}
		
	
}
}
OUTPUT:
m b c a 
e j f h 
i k g l 
p n o d 



PROGRAM TO FIND OUT IF A MAGIC INDEX EXISTS
package JDBCPack;
import java.io.*;
public class sample{
	
	public static void main(String args[])
	{   int x[]={0,2,3,5,5,5,11,13,12};
		int k=magicIndexSearch(x,0,x.length-1);
		if(k!=-1)
			System.out.println("magic index  is at positon:"+x[k]+" "+k);
		else
			System.out.println("no magic index");
	}

	public static int magicIndexSearch(int[] x, int low, int high) {
		 if(low<high)
		 {
			 int mid=(low+high)/2;
			 if(mid==x[mid])
				 return mid;
			 
			 else if(x[mid]>mid)
			 {    if(x[mid+1]==mid+1)
				      return mid+1;
			      else
				    return magicIndexSearch(x, low, mid-1);
			 }
			 else{
				    if(x[mid-1]==mid-1)
				    	return mid-1;
				    else
				  	 return magicIndexSearch(x, mid+1, high);
			 }
			  
		 }
		 else
			 return -1;
		
	}
	
}
OUTPUT:
magic index :5 5




PROGRAM TO MERGE TWO SORTED ARRAYS A & B into A.
package akash;

import java.io.*;
 
public class test2{
    
	public static void main(String args[])
	{
		int[] a={1,5,7,11,12,0,0,0,0};
		int b[]={0,3,9,13};
		 int i=a.length-b.length-1;
		 int k=a.length-1;
		 int j=b.length-1;
		 while(i>=0 && j>=0)
		 {
			 
			  if(b[j]>a[i])
			  {
				  a[k]=b[j];
				  j--;
			  }
			  else{
				  a[k]=a[i];
			       i--;
			  }
			  
			  
			  k--;
		 }
		 if(i>=0)
			 a[k]=a[i];
		 else
			 a[k]=b[j];
		 
		 
		 for(int m=0;m<a.length;m++)
			 System.out.print(a[m]+" ");
			 	 
	}
}
OUTPUT:
0 1 3 5 7 9 11 12 13 




PROGRAM TO COUNT THE NUMBER OF TWO'S THAT APPEAR IN ALL NUMBERS BETWEEN 0 AND N
INCLUSIVE:
eg:input:25
output:9 (2,12,20,21,22,23,24,25)

public class tester{
    
public static void main(String args[]) {
 int n=50;int k=0;
 int max=25;
    for(int i=1;max>0;i=i*10)	  {
      
	   k+=findCount(i,n);
	   max=max/10;
     }
    System.out.println(k);
		
	}
	
	public static int findCount(int num,int n){
		   int[] count=new int[10];
		   int arr[]=new int[n+1];
		   
		   for(int i=0;i<=n;i++)
		   {
			  arr[i] =i;
		   }
		  
		   for(int i=0;i<arr.length;i++)
		       count[(arr[i]/num)%10]= count[(arr[i]/num)%10]+1;
		 
		   
		 return count[2];
	}
	
	
	
	
}

OUTPUT:
9



RECURSIVE PROGRAM TO PRINT TRIANGULAR NUMBERS:
triangular numbers:

class dataEmpl{

 public static void main(String[] args){

     triangular(0,0);
}

public static void triangular(int n,int k){
     
    if(k==4){
         return;
      }

    k++;

    System.out.println(n+k);
    triangular(n+k,k);


}

}

OUTPUT:
1 3 6 10 15 21 28 36 